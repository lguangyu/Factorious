#!/usr/bin/env python3

import io
import sys
import json
import math
import argparse
#import textwrap
import itertools
import collections

import facc
import facc.factorio_tunes


TIME_UNITS = ["sec", "min", "hr"]
TIME_TO_SEC = {
	"sec": 1.0,
	"min": 60.0,
	"hr": 3600.0,
}
FACTORIO = facc.load_factorio_version_tunes("0.15")


def get_args():
	ap = argparse.ArgumentParser()
	ap.add_argument("targets", type = str,
		help = "production targets for calculation, in <item,rate> format for\
			each target, separated by plus (+) between targets; for example,\
			'inserter,10+iron-plate,20+science-pack-1,10'; read from stdin if\
			set to -, assuming in CSV format (each line being a target)")
	#
	ag = ap.add_argument_group("basic options")
	ag.add_argument("-r", "--recipe", type = str,
		metavar = "json", required = True,
		help = "recipe data file in json format (required)")
	ag.add_argument("--list-items", action = "store_true",
		help = "list all items in loaded recipe file and exit")
	ag.add_argument("--list-recipes", action = "store_true",
		help = "list all recipes in loaded recipe file and exit")
	ag.add_argument("-y", "--yield-level", type = str,
		choices = ["normal", "expensive"], default = "normal",
		help = "yield difficulty level (default: normal)")
	ag.add_argument("-u", "--rate-unit", type = str,
		choices = ["sec", "min", "hr"], default = "min",
		help = "assume <targets> production in per <unit> rate (default: min)")
	ag.add_argument("-g", "--graph", type = str, metavar = "png",
		help = "add a graphic visualization in addition to tabular output")
	# 
	ag = ap.add_argument_group("recipe/item options")
	ag.add_argument("-L", "--without-coal-liquefaction", action = "store_true",
		help = "exclude coal liquefaction recipe (default: off)")
	ag.add_argument("-O", "--without-oil-processing", action = "store_true",
		help = "exclude both basic and advanced oil processing recipes, tends\
		to source oil products from coal liquefaction (default: off)")
	ag.add_argument("--trivial-items", type = str,
		metavar = "item1,item2,...", default = FACTORIO.COMMON_TRIVIALS_STR,
		help = "assign listed items, separated by comma (,), to be trivial;\
			trivial items are regard as raw material and excluded from\
			optimization on consumption (default: %s)"\
			% FACTORIO.COMMON_TRIVIALS_STR)
	ag = ap.add_argument_group("optimization options")
	ag.add_argument("--tolerance", type = float,
		metavar = "float", default = 1e-6,
		help = "float comparison tolerance used in optimization (default: 1e-6)")
	args = ap.parse_args()
	return args


def main():
	args = get_args()
	# resolving args
	targets = args_get_targets(args)
	ex_recipes = args_get_excluded_recipes(args)
	trivials = args_get_trivials(args)
	obj_scales = get_optim_obj_scales(trivials)
	# load, refining data
	recp_list = load_raw_recipes(args.recipe)
	# make RecipeSet
	append_madeup_recipes_inplace(recp_list, args)
	recipe_set = get_recipe_set(recp_list,
		yield_level = args.yield_level,
		excluded_recipes = ex_recipes,
		trivial_items = trivials)
	if args.list_items:
		print_iterator(recipe_set.iterate_items())
		return
	if args.list_recipes:
		print_iterator(recipe_set.iterate_recipes())
		return
	# make production calc. object
	prod_tree = ExportableProductionTree(recipe_set)
	# do calculation
	prod_tree.calculate_targets(targets,\
		optim_args = dict(
			scales = obj_scales,
			tol = args.tolerance))
	# output
	prod_tree.to_tabular(file = sys.stdout, time_unit = args.rate_unit)
	if args.graph:
		prod_tree.visualize(file = args.graph)
	return


################################################################################
# viewing
def print_iterator(it: iter) -> None:
	for i in sorted(it):
		print(i, file = sys.stdout)

################################################################################
# target parsing
_tp_rm_empty = lambda x: bool(x) # filter empty strings
_tp_split_comma = lambda x: x.split(",")
# unpack (str, str) -> str, float -> for construct dict {key: value}
_tp_unpack = lambda x: (x[0], float(x[1]))
target_parser = lambda x: _tp_unpack(_tp_split_comma(x))


def _parse_targets_from_clistr(s: str) -> dict:
	_f = filter(_tp_rm_empty, s.split(":"))
	return dict(map(target_parser, _f))


def _parse_targets_from_csvstr(s: str) -> dict:
	_f = itertools.filter(_tp_rm_empty, s.split(":"))
	return dict(map(target_parser, _f))


def args_get_targets(_args) -> dict:
	if _args.targets == "-":
		return _parse_targets_from_csvstr(sys.stdin.read())
	else:
		return _parse_targets_from_clistr(_args.targets)


################################################################################
# load recipes
def load_raw_recipes(json_f: str) -> list:
	with open(json_f, "r") as fh:
		rs = json.load(fh)
	# ensure list
	if isinstance(rs, dict):
		# returning iterator
		rs = list(rs.values())
	return rs


def append_madeup_recipes_inplace(recipe_list, _args):
	# no need to show madeup recipes in these commands
	if _args.list_items or _args.list_recipes:
		return
	recipe_list += FACTORIO.MADEUP_RECIPES


def get_recipe_set(raws, *,
		yield_level = "normal",
		excluded_recipes: list = [],
		trivial_items: list = [],
	) -> list:
	# create Recipe objects
	recipes = []
	for v in itertools.chain(raws):
		if v["name"] not in excluded_recipes:
			if v.get(yield_level, None):
			# we tried to replace it with None on with missed "expensive"s,
			# thus below should be fine :)
			#if v[mode]:
				group = v[yield_level]
			else:
				group = v["normal"]
			_r = facc.Recipe(name = v["name"], category = v["category"],
				inputs = group["ingredients"], products = group["results"],
				craft_time = group["craft_time"])
			recipes.append(_r)
	# construct recipe set
	recipe_set = facc.RecipeSet(recipes, copy = True, net_yield = True)
	recipe_set.set_trivials(trivial_items)
	return recipe_set


def args_get_excluded_recipes(_args) -> list:
	ret = []
	if _args.without_coal_liquefaction:
		ret.append("coal-liquefaction")
	if _args.without_oil_processing:
		ret.append("basic-oil-processing")
		ret.append("advanced-oil-processing")
	return ret


def args_get_trivials(_args) -> list:
	return _args.trivial_items.split(",")


def get_optim_obj_scales(excludes: list or dict = []) -> dict:
	# currently this function does not support user specification
	# fluids are 1/10 of solids for balance
	ret = {i: 0.1 for i in FACTORIO.FLUIDS if i not in excludes}
	return ret


################################################################################
# output
def _fmt_float(v, len_lim = 7, strip_int = False):
	low_lim = math.pow(10, max(3 - len_lim, -4))
	high_lim = math.pow(10, len_lim + 1)
	_abs_v = abs(v)
	_int_v = int(round(v))
	if (_abs_v < low_lim) or (_abs_v >= high_lim):
		_format = "%%.%de" % min(len_lim - 6, 3)
	elif strip_int and math.isclose(v, _int_v) and _int_v >= 10:
		return str(_int_v)
	elif _abs_v < 0.01:
		_format = "%%.%df" % min(len_lim - 2, 4)
	elif _abs_v < 0.1:
		_format = "%%.%df" % min(len_lim - 3, 3)
	elif _abs_v < 2:
		_format = "%%.%df" % min(len_lim - 4, 2)
	#elif _abs_v < 10:
	#	_format = "%%.%df" % min(len_lim - 5, 2)
	elif _abs_v < 100:
		_format = "%%.%df" % min(len_lim - 5, 1)
	else:
		return "%d" % v
	return _format % v
	

class ExportableProductionTree(facc.ProductionTree):
	def to_tabular(self, file: io.IOBase or str, *ka, **kw) -> None:
		if isinstance(file, str):
			with open(file, "w") as fh:
				self.to_tabular(fh, *ka, **kw)
			return
		elif isinstance(file, io.IOBase):
			self.to_tabular_handler(file, *ka, **kw)
			return
		raise TypeError("'file' must be either 'str' or valid file handle")
		return


	def to_tabular_handler(self, fh, time_unit = "min", header = "") -> None:
		category_cfg = FACTORIO.RECIPE_CATEGORIES
		crafter_cfg = FACTORIO.CRAFTERS
		targ, rexe, raw, wst = self.get_current_tree()
		cons, prod = self.get_item_summary()
		########################################################################
		# header
		if header:
			print(header, file = fh)
			print("", file = fh)
		########################################################################
		# targets
		dataline_fmt = "{:>3}. {:<35}{:>20}"
		print("I. TARGETS > %d total" % len(targ), file = fh)
		print("_" * 60, file = fh)
		if not rexe:
			print(dataline_fmt.format(0, "[empty]", "-"), file = fh)
		else:
			for i, k in enumerate(sorted(targ.keys())):
				print(dataline_fmt.format(i + 1, k,\
					_fmt_float(targ[k]) + " /" + time_unit), file = fh)
		print("", file = fh)
		########################################################################
		# recipe exec
		_exu_w = 31
		_exu_totw = _exu_w * 3 + 6
		_exu_fmt = "{:<%d} {:>%d}" % (_exu_w - 10, 9)
		headline_fmt = (("_" * 40) + "_{:_>12} {:_>12} ____{:_^%d}") % _exu_totw
		dataline_fmt = ("{:>3}. {:<35} {: >12} {: >12}   | {: <%d}") % _exu_totw
		print("II. RECIPES INFO > %d total" % len(rexe), file = fh)
		headline = headline_fmt\
			.format(" exec/%s" % time_unit, " std.units", " unit [load] ")
		print("_" * len(headline), file = fh)
		print(headline, file = fh)
		if not rexe:
			print(dataline_fmt.format(0, "[empty]", *("-") * 3), file = fh)
		else:
			for i, k in enumerate(sorted(rexe.keys())):
				_recp = self.get_recipe(k)
				_exe = rexe[k]
				_std = _exe * _recp.craft_time / TIME_TO_SEC[time_unit]
				# each field format is defined above
				_exu = [_exu_fmt.format(c[:_exu_w - 9], "[%s]"\
						% _fmt_float(_std / crafter_cfg[c]["speed"])\
					) for c in category_cfg[_recp.category]]
				_exu = " | ".join([("{:^%d}" % _exu_w).format(i) for i in _exu])
				print(dataline_fmt.format(i + 1, k, _fmt_float(_exe, 12, True),\
					_fmt_float(_std, 12, True), _exu), file = fh)
		print("", file = fh)
		########################################################################
		# item consumption/production/wasting
		headline_fmt = ("_" * 40) + "_{:_>13} {:_>13} {:_>13}"
		dataline_fmt = "{:>3}. {:<35} {: >13} {: >13} {: >13}"
		for _title, _data in [
				("III. RAW MATERIAL INPUT", raw),
				("IV. ITEM CONSUMPTION", cons),
				("V. ITEM PRODUCTION", prod),
				("VI. ITEM WASTING", wst),
			]:
			print("%s INFO > %d total" % (_title, len(_data)), file = fh)
			headline = headline_fmt\
				.format(*[" ~/%s" % u for u in TIME_UNITS])
			print("_" * len(headline), file = fh)
			print(headline, file = fh)
			if not _data:
				print(dataline_fmt.format(0, "[empty]", *("-") * 3), file = fh)
			else:
				sorted_descend = sorted(_data.items(),\
					key = lambda x: x[1], reverse = True)
				for i, (k, c) in enumerate(sorted_descend):
					r = c / TIME_TO_SEC[time_unit] # per second
					print(dataline_fmt.format(i + 1, k,\
						*[_fmt_float(r * TIME_TO_SEC[u], 13)
							for u in TIME_UNITS]),
						file = fh)
			print("", file = fh)
		return


################################################################################
if __name__ == "__main__":
	main()
